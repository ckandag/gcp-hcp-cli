# Get/List Kubernetes Resources Workflow
#
# A generic workflow to get or list Kubernetes resources with optional AI analysis.
# Supports all standard Kubernetes resources and HyperShift custom resources.
# This is the kubectl-equivalent 'get' command for Zero Operator Access.
#
# Usage:
#   # List all pods in a namespace
#   gcloud workflows run get \
#     --project=<project-id> \
#     --location=<region> \
#     --data='{"resource_type": "pods", "namespace": "default"}'
#
#   # Get a specific pod
#   gcloud workflows run get \
#     --project=<project-id> \
#     --location=<region> \
#     --data='{"resource_type": "pods", "namespace": "default", "name": "my-pod"}'
#
#   # Get a pod with AI analysis
#   gcloud workflows run get \
#     --project=<project-id> \
#     --location=<region> \
#     --data='{"resource_type": "pods", "namespace": "default", "name": "my-pod", "analyze": true}'
#
# Parameters:
#   - resource_type (required): pods, deployments, services, configmaps, events, nodes, namespaces,
#                               hostedclusters, nodepools, hostedcontrolplanes
#   - namespace (optional): Required for namespaced resources (default: "default")
#   - name (optional): Specific resource name (omit for list)
#   - label_selector (optional): Filter by labels (e.g., "app=nginx")
#   - analyze (optional): If true and resource is a pod, fetch logs and run AI analysis (default: false)
#
# Note: List operations are limited to 20 items to prevent Cloud Workflows memory exhaustion.
#       If more resources exist, the response includes a 'note' field. The 20-item sample is
#       sufficient for diagnosis and troubleshooting.

main:
  params: [args]
  steps:
    - validate_inputs:
        switch:
          - condition: ${not("resource_type" in args)}
            raise: "Missing required parameter: resource_type"

    # Security: Block sensitive resource types
    - check_resource_type_deny_list:
        switch:
          - condition: ${args.resource_type == "secrets" or args.resource_type == "configmaps"}
            raise:
              code: 403
              message: '${"Resource type ''" + args.resource_type + "'' is blocked for security. Secrets and configmaps cannot be queried."}'

    - init:
        assign:
          - project: ${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}
          - cluster_id: ${sys.get_env("CLUSTER_NAME")}
          - location: ${sys.get_env("CLUSTER_LOCATION")}
          - resource_type: ${args.resource_type}
          - namespace: ${default(map.get(args, "namespace"), "default")}
          - name: ${default(map.get(args, "name"), "")}
          - label_selector: ${default(map.get(args, "label_selector"), "")}
          - analyze: ${default(map.get(args, "analyze"), false)}
          - allowed_namespaces: ${sys.get_env("ALLOWED_NAMESPACES", "")}
          - nl: "\n"

    # Security: Validate namespace against allow-list (if configured)
    - check_namespace_allow_list:
        switch:
          - condition: ${allowed_namespaces != "" and namespace != "" and not(text.match_regex(("," + allowed_namespaces + ","), (".*," + namespace + ",.*")))}
            raise:
              code: 403
              message: '${"Namespace ''" + namespace + "'' is not in the allowed list. Allowed: " + allowed_namespaces}'

    # Resource routing table - maps resource types to API paths
    - setup_routing:
        assign:
          # Core API resources
          - api_routes:
              pods:
                api_prefix: "/api/v1"
                namespaced: true
              services:
                api_prefix: "/api/v1"
                namespaced: true
              configmaps:
                api_prefix: "/api/v1"
                namespaced: true
              events:
                api_prefix: "/api/v1"
                namespaced: true
              nodes:
                api_prefix: "/api/v1"
                namespaced: false
              namespaces:
                api_prefix: "/api/v1"
                namespaced: false
              persistentvolumes:
                api_prefix: "/api/v1"
                namespaced: false
              persistentvolumeclaims:
                api_prefix: "/api/v1"
                namespaced: true
              # Apps API resources
              deployments:
                api_prefix: "/apis/apps/v1"
                namespaced: true
              statefulsets:
                api_prefix: "/apis/apps/v1"
                namespaced: true
              daemonsets:
                api_prefix: "/apis/apps/v1"
                namespaced: true
              replicasets:
                api_prefix: "/apis/apps/v1"
                namespaced: true
              # HyperShift resources
              hostedclusters:
                api_prefix: "/apis/hypershift.openshift.io/v1beta1"
                namespaced: true
              nodepools:
                api_prefix: "/apis/hypershift.openshift.io/v1beta1"
                namespaced: true
              hostedcontrolplanes:
                api_prefix: "/apis/hypershift.openshift.io/v1beta1"
                namespaced: true
              # Cluster API resources
              machinedeployments:
                api_prefix: "/apis/cluster.x-k8s.io/v1beta1"
                namespaced: true
              machines:
                api_prefix: "/apis/cluster.x-k8s.io/v1beta1"
                namespaced: true
              machinesets:
                api_prefix: "/apis/cluster.x-k8s.io/v1beta1"
                namespaced: true
              # Cluster API infrastructure provider resources (GCP)
              gcpmachines:
                api_prefix: "/apis/infrastructure.cluster.x-k8s.io/v1beta1"
                namespaced: true
              gcpmachinetemplates:
                api_prefix: "/apis/infrastructure.cluster.x-k8s.io/v1beta1"
                namespaced: true

    - validate_resource_type:
        switch:
          - condition: ${not(resource_type in api_routes)}
            raise: '${"Unsupported resource type: " + resource_type + ". Supported: pods, deployments, services, configmaps, events, nodes, namespaces, hostedclusters, nodepools, hostedcontrolplanes"}'

    - get_route_config:
        assign:
          - route: ${api_routes[resource_type]}
          - is_namespaced: ${route.namespaced}
          - api_prefix: ${route.api_prefix}

    - validate_namespace:
        switch:
          - condition: ${is_namespaced and namespace == ""}
            raise: '${"Resource type " + resource_type + " requires a namespace"}'

    - build_path:
        switch:
          # Cluster-scoped resource - no namespace in path
          - condition: ${not(is_namespaced)}
            assign:
              - base_path: '${api_prefix + "/" + resource_type}'
          # Namespaced resource
          - condition: true
            assign:
              - base_path: '${api_prefix + "/namespaces/" + namespace + "/" + resource_type}'

    - add_name_to_path:
        switch:
          - condition: ${name != ""}
            assign:
              - resource_path: '${base_path + "/" + name}'
          - condition: true
            assign:
              - resource_path: ${base_path}

    # Build query parameters for list operations
    # Cloud Workflows has ~256KB memory limit - large responses cause MemoryLimitExceededError
    # Adding limit=20 prevents memory exhaustion when listing resources in large namespaces
    # (20 pods with full metadata â‰ˆ 160KB, safely under the 256KB limit)
    - build_query_params:
        switch:
          # List operation with label selector
          - condition: ${label_selector != "" and name == ""}
            assign:
              - resource_path: '${resource_path + "?limit=20&labelSelector=" + text.url_encode(label_selector)}'
          # List operation without label selector
          - condition: ${name == ""}
            assign:
              - resource_path: '${resource_path + "?limit=20"}'
          # Single resource fetch - no query params needed
          - condition: true
            next: get_resource

    - get_resource:
        call: gke.request
        args:
          project: ${project}
          cluster_id: ${cluster_id}
          location: ${location}
          method: "GET"
          path: ${resource_path}
        result: resource_response

    # Check if we should run AI analysis (only for pods with a specific name)
    - check_analyze:
        switch:
          - condition: ${analyze == true and resource_type == "pods" and name != ""}
            next: extract_pod_status
          - condition: true
            next: format_result

    # Extract pod status and container info before fetching logs
    - extract_pod_status:
        assign:
          - pod_phase: ${resource_response.body.status.phase}
          - container_statuses: ${default(map.get(resource_response.body.status, "containerStatuses"), [])}
          - conditions: ${default(map.get(resource_response.body.status, "conditions"), [])}
          - containers: ${resource_response.body.spec.containers}
          - all_logs: ""
          - total_log_lines: 0

    # Fetch logs from each container (multi-container pods require container= parameter)
    - fetch_container_logs:
        for:
          value: container
          in: ${containers}
          steps:
            - fetch_one_container_log:
                try:
                  steps:
                    - do_fetch_log:
                        call: gke.request
                        args:
                          project: ${project}
                          cluster_id: ${cluster_id}
                          location: ${location}
                          method: "GET"
                          path: '${"/api/v1/namespaces/" + namespace + "/pods/" + name + "/log?tailLines=500&container=" + container.name}'
                        result: one_log_response
                    - count_log_lines:
                        assign:
                          - total_log_lines: ${total_log_lines + len(text.split(one_log_response.body, nl))}
                except:
                  as: e
                  steps:
                    - set_error_log:
                        assign:
                          - one_log_response:
                              body: "(no logs available)"
            - append_container_logs:
                assign:
                  - all_logs: '${all_logs + "=== Container: " + container.name + " ===" + nl + one_log_response.body + nl + nl}'

    - get_events_for_analysis:
        try:
          call: gke.request
          args:
            project: ${project}
            cluster_id: ${cluster_id}
            location: ${location}
            method: "GET"
            path: '${"/api/v1/namespaces/" + namespace + "/events?fieldSelector=involvedObject.name=" + name}'
          result: events_response
        except:
          as: e
          steps:
            - set_empty_events:
                assign:
                  - events_response:
                      body:
                        items: []

    - build_ai_prompt:
        assign:
          - instructions: "You are a Kubernetes and HyperShift expert. Analyze this pod's logs and status to diagnose issues. Respond ONLY with a JSON object (no markdown fencing, no extra text) using exactly these keys: \"Summary\" (string, 2-3 sentences), \"Errors Detected\" (array of strings), \"Root Cause Analysis\" (string), \"Recommended Actions\" (array of strings), \"Severity\" (string, one of LOW/MEDIUM/HIGH/CRITICAL)."
          - pod_info: '${nl + "Pod: " + name + " Namespace: " + namespace + " Phase: " + pod_phase}'
          - status_info: '${nl + "Container Statuses: " + json.encode_to_string(container_statuses)}'
          - cond_info: '${nl + "Pod Conditions: " + json.encode_to_string(conditions)}'
          - events_info: '${nl + "Events: " + json.encode_to_string(events_response.body.items)}'
          - logs_info: '${nl + "Logs:" + nl + all_logs}'
          - prompt_text: '${instructions + pod_info + status_info + cond_info + events_info + logs_info}'

    - call_vertex_ai:
        try:
          call: http.post
          args:
            url: '${"https://" + location + "-aiplatform.googleapis.com/v1/projects/" + project + "/locations/" + location + "/publishers/google/models/gemini-2.0-flash:generateContent"}'
            auth:
              type: OAuth2
            timeout: 60
            body:
              contents:
                - role: "user"
                  parts:
                    - text: ${prompt_text}
          result: analysis_response
        except:
          as: ai_error
          steps:
            - return_without_analysis:
                return:
                  status: "success"
                  resource_type: ${resource_type}
                  namespace: ${namespace}
                  name: ${name}
                  resource: ${resource_response.body}
                  analysis:
                    pod_phase: ${pod_phase}
                    container_statuses: ${container_statuses}
                    events_count: ${len(events_response.body.items)}
                    log_lines_analyzed: ${total_log_lines}
                    ai_analysis: null
                    error: "AI analysis unavailable"

    - return_with_analysis:
        return:
          status: "success"
          resource_type: ${resource_type}
          namespace: ${namespace}
          name: ${name}
          resource: ${resource_response.body}
          analysis:
            pod_phase: ${pod_phase}
            container_statuses: ${container_statuses}
            events_count: ${len(events_response.body.items)}
            log_lines_analyzed: ${total_log_lines}
            ai_analysis: ${analysis_response.body.candidates[0].content.parts[0].text}

    # Format result for list vs single resource
    - format_result:
        switch:
          - condition: ${name != ""}
            next: return_single_resource
          - condition: true
            next: return_resource_list

    - return_single_resource:
        return:
          status: "success"
          resource_type: ${resource_type}
          namespace: ${if(is_namespaced, namespace, null)}
          name: ${name}
          resource: ${resource_response.body}

    - return_resource_list:
        return:
          status: "success"
          resource_type: ${resource_type}
          namespace: ${if(is_namespaced, namespace, null)}
          count: ${len(resource_response.body.items)}
          # Note: Response limited to first 20 items for performance. This sample is sufficient for diagnosis.
          note: ${if(map.get(resource_response.body.metadata, "continue") != null, "Showing first 20 items (more exist). This sample is sufficient for diagnosis.", null)}
          items: ${resource_response.body.items}